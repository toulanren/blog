# JavaScript 的垃圾回收机制

### 内存管理（垃圾收集机制）

内存管理的机制就是周期性执行这个操作：

- 找出不再使用的变量，释放其空间。

主要有以下两种方式：

- 标记清除
- 引用计数

#### 标记清除

标记清除是 JavaScript 最常用的内存管理机制，即当变量进入环境时，则标记这个变量为进入，而当变量离开环境时，则将其标记为离开。

```js
function add(n){
  var sum += n;    // 进入
  return sum;      // 离开
}
add(1); // 1
```

变量的定义和赋空值，也会出发标记清除：

```js
var user = {
  name: 'jack',
  age: 20
} // 在作用域定义变量，标记变量为进入

// some code ...

user = null //最后定义为null，标记变量为离开，释放内存
```

#### 引用计数

引用计数是不太常见的内存管理机制，顾名思义，引用计数会跟踪记录每个值被引用的次数，若是为 0 则清除。

```js
var user = {
  name: 'jack',
  age: 20
} // 引用次数 + 1

// some code ...

user = null // 最后定义为null，引用计数 -1 ，为0清除
```

> 但引用计数会因为变量相互引用，造成内存计数永不为 0，故而虽然已经执行完了代码，但是还是不会清除变量。

```js
function a() {
  var b = {}
  var c = {}
  b.test = c
  c.test = b
}
a() // 虽然 a 已经执行完，但是还是不会清楚 b 和 c 。
```

#### 总结

虽然大多浏览器上 JavaScript 的内存管理机制是标记清除，但是在 IE 浏览器（又是它）中，某些对象的内存管理机制是引用计数，如 IE 的 DOM 和 BOM，（统称为 COM 对象），所以在写代码时要避免相互引用。

---

### 内存泄漏

首先，内存泄漏并不是不合理的，如闭包就会造成内存泄漏，但是大家还是在使用闭包的方式写函数，所以存在即合理，需要做的，是在合理使用的情况下把不合理的去掉。

常见的造成内存泄漏的情况：

- 定义全局对象
- 闭包
- dom 清空或删除时，事件未清除
- 相互引用

由上可知，基本解决方案就是：

- 不要轻易定义全局变量
- 如果有必要，尽量减少闭包函数。
- 删除 dom 时，清除 dom 以及其子节点绑定的函数
- 不要相互引用，即使要相互引用，最后请加一个 a = null 切断联系
