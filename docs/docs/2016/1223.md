# JavaScript 声明的剖析

### 何为变量/函数提升

抽象一下变量/函数声明的过程，其过程实质为：创建、初始化、赋值、引用

| 过程   |                描述                |
| ------ | :--------------------------------: |
| 创建   |     在当前执行块中注册此变量名     |
| 初始化 | 在内存中初始化存储空间并存储初始值 |
| 赋值   |   即字面量的意思，赋值，存储数据   |
| 引用   | 即字面量的意思，引用/调用变量/函数 |

> PS：变量/函数需初始化后方可进行引用，否则报错 is not defined

当声明变量/函数时，JS 解析器提升其过程，故而存在不同的特性，如：

- var 声明语句提升了创建、初始化的过程，故在申明语句前也可调用。
- let/const 声明语句提升了创建过程，故在申明语句后方可使用。
- function 声明提升了创建、初始化、赋值的过程，故在申明语句前可执行此方法。

> PS：故 let 和 const 的唯一区别就是 const 没有赋值过程，const 只有在初始化完成初始值的存储。

> PS：运算符的 {} 会隔断函数提升，而不会隔断变量提升，但 {} 内部函数声明是否会覆盖外部声明依解析器不同则有不同的表现形式。

#### 同名变量和函数的声明

既然有变量和函数的提升，那么就会有同名情况下的先后顺序问题，实际在提升时，**函数的提升过程永远大于变量**，所以理论上是同名变量覆盖同名函数。

但如果函数和变量同名，而如果变量未赋值，则依旧使用的函数体，因为 var 是创建过程，而 = 才是赋值过程，没有赋值，仅定义变量，则不会覆盖函数，看下面的例子。

```js
function a() {}
var a
typeof a // function

// 思考：如果这样呢？
function b() {}
var b = 1
typeof b // number
```

---

### 函数声明和函数表达式的区别

函数声明和函数表达式的作用差不多，但是其概念不同。

- 函数声明：在作用域中声明一个具名函数
- 函数表达式：在作用域中创建一个匿名函数，并将函数进行运算操作

由上节可知，函数声明会被提升，所以可以在其之前使用。
而如果以函数表达式的形式声明并赋值，则无法在其之前使用。

```js
a() // aaa
function a() {
  console.log('aaa')
}

b() // Uncaught ReferenceError: b is not defined
var b = function () {
  console.log(b)
}
```

再由上节可知，运算符的 {} 会隔断函数提升，所以：

```js
a() // Uncaught ReferenceError: a is not defined
if (1) {
  function a() {
    console.log('aaa')
  }
}
```

#### 函数表达式的常用场景

都知道立即执行函数这样写，那为什么可以这样写呢？

```js
;(function (win) {
  // some code ...
})(window)
```

答案：因为 JS 解析器需要区分函数声明和函数表达式，所以这样写：

```js
function(){
  // some code ...
}()
```

JS 解析器会认为你定义了函数，而这样的声明明显是错误语法，所以需要使用运算符来区别，所以会像如上写法增加括号，这样 JS 解析器会认为你正在定义了函数表达式，并将进行操作。

那么举一反三，也可以这样写。

```js
!(function (win) {
  // some code ...
})(window)
;+(function (win) {
  // some code ...
})(window)
;-(function (win) {
  // some code ...
})(window)
```

但是因为 + - 这些符号会和上一行进行运算，所以常见的是 () 和 ! ，所以立即执行函数，实质是就是函数表达式的巧用。
